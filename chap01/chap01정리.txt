시리즈 : 1차원 배열
pd.Series(###)

원소를 선택하는 법
sr[0] #슬라이싱 가능
sr[인덱스 이름] # 슬라이싱 가능

데이터 프레임 : 2차원 배열
pd.DataFrame(###)

*데이터 프레임 객체 -? df
index(행) / columns(열)

df.index-> 인덱스값을 확인
df.columns -> 열 이름 값을 확인

rename -> 기존 인덱스(or열)를 재할당

행/열 삭제

drop()

행 삭제 : axis=0(default)
열 삭제 : axis=1 #반드시 적어줘야함

*행 선택*
loc -> 인덱스 이름으로 선택
iloc -> 정수형 위치 인덱스 선택
주의할점
loc['a':'d'] -> 'd' 포함
iloc[0:4] -> 4 미포함 

*열선택

df['열 이름']

<원소 선택>
df.loc[행 인덱스, 열 이름]
df.iloc[행 번호, 열 번호]
=> 슬라이승 가능

<열 추가>
df['추가 열 이름']=데이터 값

<행 추가>

df.loc['새로운 행 이름']= 데이터 값

<원소값 변경>

원소 선택과 비슷
원소를 선택해서 = 새로운값 을 할당 하면 됨

ex>
df.iloc[0][1] = 새로운 값
df.loc['행 인덱스']['열 이름'] = 새로운값

<행>

<특정 열을 행 인덱스로 설정>

df.set_index(['열 이름'])

<행 인덱스 재배열>

df.reindex(새로운 인덱스 배열)
->  기존 인덱스에서해당하지 않는 새로운 인덱스 값원소는 NaN값이 할당

<행 인덱스 초기화>
df.reset_index()

<행 인덱스를 기준으로 데이터 프레임 정렬>
df.sort_index()
ascending=True/False (오름차순/내림차순)

cf)
df.sort_values(by='열이름')
=> '열 이름'에 해당하는 원소를 기준으로 정렬

<시리즈 연산>

*인덱스 이름이 같은 원소끼리 연산이 된다*

시리즈+숫자

시리즈+시리즈
=> 인덱스이름이 다른 시리즈에 없는 경우 NaN값으로 처리한다.
연산자(+,-,*,/)가능
연산 메소드도 가능   add()/ sub(0/ mul()/ div()

NaN값을 0으로 대체
연산메소드 옵션에 fill_value=0 대입

[데이터 프레임 연산]

데프 + 숫자
데프 +데프

NaN값이 원소일 경우 연산결과는 무조건 NaN